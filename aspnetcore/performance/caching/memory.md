---
title: Almacenar en memoria caché en ASP.NET Core
author: rick-anderson
description: Obtenga información sobre cómo almacenar los datos en la memoria caché en ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: 1967fb1942b4003d498800f6cf4c9dd280aca24e
ms.sourcegitcommit: 688b6f448d87b6f7f4440182d72388eaa68d2935
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 05/14/2020
ms.locfileid: "83393852"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="b6938-103">Almacenar en memoria caché en ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="b6938-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="b6938-104">Por [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)y [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="b6938-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="b6938-105">[Vea o descargue el código de ejemplo](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([cómo descargarlo](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="b6938-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="b6938-106">Conceptos básicos de almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="b6938-106">Caching basics</span></span>

<span data-ttu-id="b6938-107">El almacenamiento en caché puede mejorar significativamente el rendimiento y la escalabilidad de una aplicación reduciendo el trabajo necesario para generar contenido.</span><span class="sxs-lookup"><span data-stu-id="b6938-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="b6938-108">El almacenamiento en caché funciona mejor con los datos que cambian con poca frecuencia **y** que son caros de generar.</span><span class="sxs-lookup"><span data-stu-id="b6938-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="b6938-109">Caching realiza una copia de los datos que se pueden devolver mucho más rápido que desde el origen.</span><span class="sxs-lookup"><span data-stu-id="b6938-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="b6938-110">Las aplicaciones deben escribirse y probarse para que **nunca** dependan de los datos almacenados en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="b6938-111">ASP.NET Core admite varias memorias caché diferentes.</span><span class="sxs-lookup"><span data-stu-id="b6938-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="b6938-112">La memoria caché más sencilla se basa en el [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="b6938-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="b6938-113">`IMemoryCache`representa una memoria caché almacenada en la memoria del servidor Web.</span><span class="sxs-lookup"><span data-stu-id="b6938-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="b6938-114">Las aplicaciones que se ejecutan en una granja de servidores (varios servidores) deben asegurarse de que las sesiones son permanentes al usar la memoria caché en memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="b6938-115">Las sesiones permanentes garantizan que todas las solicitudes posteriores de un cliente van al mismo servidor.</span><span class="sxs-lookup"><span data-stu-id="b6938-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="b6938-116">Por ejemplo, Azure Web Apps usa el [enrutamiento de solicitud de aplicaciones](https://www.iis.net/learn/extensions/planning-for-arr) (arr) para enrutar todas las solicitudes posteriores al mismo servidor.</span><span class="sxs-lookup"><span data-stu-id="b6938-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="b6938-117">Las sesiones no permanentes en una granja de servidores Web requieren una [caché distribuida](distributed.md) para evitar problemas de coherencia de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="b6938-118">En algunas aplicaciones, una caché distribuida puede admitir una mayor escalabilidad horizontal que una caché en memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="b6938-119">El uso de una caché distribuida descarga la memoria caché en un proceso externo.</span><span class="sxs-lookup"><span data-stu-id="b6938-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="b6938-120">La caché en memoria puede almacenar cualquier objeto.</span><span class="sxs-lookup"><span data-stu-id="b6938-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="b6938-121">La interfaz de caché distribuida se limita a `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="b6938-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="b6938-122">Los elementos de caché del almacén de caché distribuida y en memoria como pares de clave y valor.</span><span class="sxs-lookup"><span data-stu-id="b6938-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="b6938-123">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="b6938-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="b6938-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Paquete NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) se puede usar con:</span><span class="sxs-lookup"><span data-stu-id="b6938-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="b6938-125">.NET Standard 2,0 o posterior.</span><span class="sxs-lookup"><span data-stu-id="b6938-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="b6938-126">Cualquier [implementación de .net](/dotnet/standard/net-standard#net-implementation-support) que tenga como destino .net Standard 2,0 o posterior.</span><span class="sxs-lookup"><span data-stu-id="b6938-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="b6938-127">Por ejemplo, ASP.NET Core 2,0 o posterior.</span><span class="sxs-lookup"><span data-stu-id="b6938-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="b6938-128">.NET Framework 4.5 o superior.</span><span class="sxs-lookup"><span data-stu-id="b6938-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="b6938-129">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (que se describe en este artículo) se recomienda en lugar de `System.Runtime.Caching` / `MemoryCache` que se integre mejor en ASP.net Core.</span><span class="sxs-lookup"><span data-stu-id="b6938-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="b6938-130">Por ejemplo, `IMemoryCache` funciona de forma nativa con la [inserción de dependencias](xref:fundamentals/dependency-injection)ASP.net Core.</span><span class="sxs-lookup"><span data-stu-id="b6938-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="b6938-131">Use `System.Runtime.Caching` / `MemoryCache` como puente de compatibilidad al trasladar código de ASP.net 4. x a ASP.net Core.</span><span class="sxs-lookup"><span data-stu-id="b6938-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="b6938-132">Instrucciones de caché</span><span class="sxs-lookup"><span data-stu-id="b6938-132">Cache guidelines</span></span>

* <span data-ttu-id="b6938-133">El código siempre debe tener una opción de reserva para capturar datos y **no** depender de que un valor almacenado en caché esté disponible.</span><span class="sxs-lookup"><span data-stu-id="b6938-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="b6938-134">La memoria caché utiliza un recurso y una memoria insuficientes.</span><span class="sxs-lookup"><span data-stu-id="b6938-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="b6938-135">Limitar el crecimiento de la caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-135">Limit cache growth:</span></span>
  * <span data-ttu-id="b6938-136">**No** utilice la entrada externa como claves de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="b6938-137">Use las expiraciones para limitar el crecimiento de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="b6938-138">[Use setSize, size y SizeLimit para limitar el tamaño de la memoria caché](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="b6938-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="b6938-139">El tiempo de ejecución de ASP.NET Core **no limita el** tamaño de la memoria caché en función de la presión de memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="b6938-140">Depende del desarrollador limitar el tamaño de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="b6938-141">Usar IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="b6938-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="b6938-142">El uso de una caché de memoria *compartida* de la [inserción de dependencias](xref:fundamentals/dependency-injection) y `SetSize` la llamada a, `Size` o `SizeLimit` para limitar el tamaño de la memoria caché puede provocar un error en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="b6938-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="b6938-143">Cuando se establece un límite de tamaño en una memoria caché, todas las entradas deben especificar un tamaño al agregarse.</span><span class="sxs-lookup"><span data-stu-id="b6938-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="b6938-144">Esto puede dar lugar a problemas, ya que es posible que los desarrolladores no tengan control total sobre lo que utiliza la memoria caché compartida.</span><span class="sxs-lookup"><span data-stu-id="b6938-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="b6938-145">Por ejemplo, Entity Framework Core usa la memoria caché compartida y no especifica un tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="b6938-146">Si una aplicación establece un límite de tamaño de caché y usa EF Core, la aplicación produce una excepción `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="b6938-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="b6938-147">Al usar `SetSize` , `Size` o `SizeLimit` para limitar la memoria caché, cree un singleton de caché para el almacenamiento en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="b6938-148">Para obtener más información y un ejemplo, vea [uso de setSize, size y SizeLimit para limitar el tamaño de la memoria caché](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="b6938-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="b6938-149">Una caché compartida es una compartida por otros marcos o bibliotecas.</span><span class="sxs-lookup"><span data-stu-id="b6938-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="b6938-150">Por ejemplo, EF Core usa la memoria caché compartida y no especifica un tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="b6938-151">El almacenamiento en caché en memoria es un *servicio* al que se hace referencia desde una aplicación mediante la [inserción de dependencias](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="b6938-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="b6938-152">Solicite la `IMemoryCache` instancia en el constructor:</span><span class="sxs-lookup"><span data-stu-id="b6938-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="b6938-153">En el código siguiente se usa [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) para comprobar si una hora está en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="b6938-154">Si una hora no está almacenada en caché, se crea una nueva entrada y se agrega a la memoria caché con [set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="b6938-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="b6938-155">La `CacheKeys` clase forma parte del ejemplo de descarga.</span><span class="sxs-lookup"><span data-stu-id="b6938-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="b6938-156">Se muestran la hora actual y la hora almacenada en caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="b6938-157">El valor almacenado en caché `DateTime` permanece en la memoria caché mientras haya solicitudes dentro del período de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="b6938-157">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="b6938-158">En el código siguiente se usa [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) y [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) para almacenar datos en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-158">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="b6938-159">El siguiente código llama a [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) para capturar la hora almacenada en caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-159">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="b6938-160">El código siguiente obtiene o crea un elemento almacenado en caché con una expiración absoluta:</span><span class="sxs-lookup"><span data-stu-id="b6938-160">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="b6938-161">Un conjunto de elementos almacenados en caché con una expiración variable solo está en riesgo de ser obsoleto.</span><span class="sxs-lookup"><span data-stu-id="b6938-161">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="b6938-162">Si se tiene acceso con más frecuencia que el intervalo de expiración variable, el elemento nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="b6938-162">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="b6938-163">Combine una expiración variable con una expiración absoluta para garantizar que el elemento expira una vez que se supera su hora de expiración absoluta.</span><span class="sxs-lookup"><span data-stu-id="b6938-163">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="b6938-164">La expiración absoluta establece un límite superior para el tiempo que se puede almacenar en caché el elemento y, al mismo tiempo, permite que el elemento expire antes si no se solicita dentro del intervalo de expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-164">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="b6938-165">Cuando se especifica la expiración absoluta y la variable, las expiraciones se establecen lógicamente.</span><span class="sxs-lookup"><span data-stu-id="b6938-165">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="b6938-166">Si el intervalo de expiración variable *o* el tiempo de expiración absoluto se superan, el elemento se expulsa de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-166">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="b6938-167">El código siguiente obtiene o crea un elemento en caché con una expiración variable *y* absoluta:</span><span class="sxs-lookup"><span data-stu-id="b6938-167">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="b6938-168">El código anterior garantiza que los datos no se almacenarán en caché durante más tiempo que el tiempo absoluto.</span><span class="sxs-lookup"><span data-stu-id="b6938-168">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="b6938-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> y <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> son métodos de extensión de la <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> clase.</span><span class="sxs-lookup"><span data-stu-id="b6938-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="b6938-170">Estos métodos amplían la capacidad de <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="b6938-170">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="b6938-171">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="b6938-171">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="b6938-172">El ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="b6938-172">The following sample:</span></span>

* <span data-ttu-id="b6938-173">Establece una hora de expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-173">Sets a sliding expiration time.</span></span> <span data-ttu-id="b6938-174">Las solicitudes que tengan acceso a este elemento almacenado en caché restablecerán el reloj de expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-174">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="b6938-175">Establece la prioridad de la memoria caché en [CacheItemPriority. NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span><span class="sxs-lookup"><span data-stu-id="b6938-175">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="b6938-176">Establece un [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) que se llamará después de que la entrada se expulse de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-176">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="b6938-177">La devolución de llamada se ejecuta en un subproceso diferente del código que quita el elemento de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-177">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="b6938-178">Use setSize, size y SizeLimit para limitar el tamaño de la memoria caché</span><span class="sxs-lookup"><span data-stu-id="b6938-178">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="b6938-179">`MemoryCache`Opcionalmente, una instancia puede especificar y exigir un límite de tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-179">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="b6938-180">El límite de tamaño de caché no tiene una unidad de medida definida porque la memoria caché no tiene ningún mecanismo para medir el tamaño de las entradas.</span><span class="sxs-lookup"><span data-stu-id="b6938-180">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="b6938-181">Si se establece el límite de tamaño de la caché, todas las entradas deben especificar el tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-181">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="b6938-182">El tiempo de ejecución de ASP.NET Core no limita el tamaño de la memoria caché en función de la presión de memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-182">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="b6938-183">Depende del desarrollador limitar el tamaño de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-183">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="b6938-184">El tamaño especificado se encuentra en las unidades que el desarrollador elige.</span><span class="sxs-lookup"><span data-stu-id="b6938-184">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="b6938-185">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="b6938-185">For example:</span></span>

* <span data-ttu-id="b6938-186">Si la aplicación web estaba principalmente almacenando en caché cadenas, cada tamaño de entrada de caché podría ser la longitud de la cadena.</span><span class="sxs-lookup"><span data-stu-id="b6938-186">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="b6938-187">La aplicación puede especificar el tamaño de todas las entradas como 1 y el límite de tamaño es el recuento de entradas.</span><span class="sxs-lookup"><span data-stu-id="b6938-187">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="b6938-188">Si <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> no se establece, la caché crece sin enlazar.</span><span class="sxs-lookup"><span data-stu-id="b6938-188">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="b6938-189">El tiempo de ejecución de ASP.NET Core no recorta la memoria caché cuando la memoria del sistema es baja.</span><span class="sxs-lookup"><span data-stu-id="b6938-189">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="b6938-190">Las aplicaciones deben diseñarse para:</span><span class="sxs-lookup"><span data-stu-id="b6938-190">Apps must be architected to:</span></span>

* <span data-ttu-id="b6938-191">Limitar el crecimiento de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-191">Limit cache growth.</span></span>
* <span data-ttu-id="b6938-192">Llame a <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> o <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> cuando la memoria disponible esté limitada:</span><span class="sxs-lookup"><span data-stu-id="b6938-192">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="b6938-193">En el código siguiente se crea un tamaño fijo no <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> disponible accesible por la [inserción de dependencias](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="b6938-193">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="b6938-194">`SizeLimit`no tiene unidades.</span><span class="sxs-lookup"><span data-stu-id="b6938-194">`SizeLimit` does not have units.</span></span> <span data-ttu-id="b6938-195">Las entradas almacenadas en caché deben especificar el tamaño en las unidades que consideren más adecuadas si se ha establecido el límite de tamaño de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-195">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="b6938-196">Todos los usuarios de una instancia de caché deben usar el mismo sistema de unidad.</span><span class="sxs-lookup"><span data-stu-id="b6938-196">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="b6938-197">Una entrada no se almacenará en caché si la suma de los tamaños de las entradas almacenadas en caché supera el valor especificado por `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="b6938-197">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="b6938-198">Si no se establece ningún límite de tamaño de caché, se omitirá el tamaño de la memoria caché establecido en la entrada.</span><span class="sxs-lookup"><span data-stu-id="b6938-198">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="b6938-199">El código siguiente se registra `MyMemoryCache` con el contenedor de [inserción de dependencias](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="b6938-199">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="b6938-200">`MyMemoryCache`se crea como una caché de memoria independiente para los componentes que tienen en cuenta esta caché de tamaño limitado y saben cómo establecer el tamaño de la entrada de caché de forma adecuada.</span><span class="sxs-lookup"><span data-stu-id="b6938-200">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="b6938-201">El código siguiente usa `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="b6938-201">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="b6938-202">El tamaño de la entrada de caché se puede establecer mediante <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> o los <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> métodos de extensión:</span><span class="sxs-lookup"><span data-stu-id="b6938-202">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="b6938-203">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="b6938-203">MemoryCache.Compact</span></span>

<span data-ttu-id="b6938-204">`MemoryCache.Compact`intenta quitar el porcentaje especificado de la memoria caché en el siguiente orden:</span><span class="sxs-lookup"><span data-stu-id="b6938-204">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="b6938-205">Todos los elementos expirados.</span><span class="sxs-lookup"><span data-stu-id="b6938-205">All expired items.</span></span>
* <span data-ttu-id="b6938-206">Elementos por prioridad.</span><span class="sxs-lookup"><span data-stu-id="b6938-206">Items by priority.</span></span> <span data-ttu-id="b6938-207">En primer lugar, se quitan los elementos de prioridad más baja.</span><span class="sxs-lookup"><span data-stu-id="b6938-207">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="b6938-208">Objetos usados menos recientemente.</span><span class="sxs-lookup"><span data-stu-id="b6938-208">Least recently used objects.</span></span>
* <span data-ttu-id="b6938-209">Elementos con la expiración absoluta más temprana.</span><span class="sxs-lookup"><span data-stu-id="b6938-209">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="b6938-210">Elementos con la primera expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-210">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="b6938-211">Los elementos anclados con prioridad <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nunca se quitan.</span><span class="sxs-lookup"><span data-stu-id="b6938-211">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="b6938-212">El código siguiente quita un elemento de la memoria caché y llama a `Compact` :</span><span class="sxs-lookup"><span data-stu-id="b6938-212">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="b6938-213">Consulte [código fuente compacto en github](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="b6938-213">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="b6938-214">Dependencias de caché</span><span class="sxs-lookup"><span data-stu-id="b6938-214">Cache dependencies</span></span>

<span data-ttu-id="b6938-215">En el ejemplo siguiente se muestra cómo expirar una entrada de caché si una entrada dependiente expira.</span><span class="sxs-lookup"><span data-stu-id="b6938-215">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="b6938-216"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Se agrega al elemento almacenado en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-216">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="b6938-217">Cuando `Cancel` se llama a en `CancellationTokenSource` , se expulsan ambas entradas de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-217">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="b6938-218">El uso de <xref:System.Threading.CancellationTokenSource> permite desalojar varias entradas de caché como un grupo.</span><span class="sxs-lookup"><span data-stu-id="b6938-218">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="b6938-219">Con el `using` patrón en el código anterior, las entradas de caché que se crean dentro del `using` bloque heredarán los desencadenadores y la configuración de expiración.</span><span class="sxs-lookup"><span data-stu-id="b6938-219">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="b6938-220">Notas adicionales</span><span class="sxs-lookup"><span data-stu-id="b6938-220">Additional notes</span></span>

* <span data-ttu-id="b6938-221">La expiración no se produce en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="b6938-221">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="b6938-222">No hay ningún temporizador que busque activamente en la caché los elementos expirados.</span><span class="sxs-lookup"><span data-stu-id="b6938-222">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="b6938-223">Cualquier actividad en la memoria caché ( `Get` , `Set` , `Remove` ) puede desencadenar un análisis en segundo plano de los elementos expirados.</span><span class="sxs-lookup"><span data-stu-id="b6938-223">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="b6938-224">Un temporizador en `CancellationTokenSource` ( <xref:System.Threading.CancellationTokenSource.CancelAfter*> ) también quita la entrada y desencadena un examen de los elementos expirados.</span><span class="sxs-lookup"><span data-stu-id="b6938-224">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and trigger a scan for expired items.</span></span> <span data-ttu-id="b6938-225">En el ejemplo siguiente se usa [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) para el token registrado.</span><span class="sxs-lookup"><span data-stu-id="b6938-225">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="b6938-226">Cuando se activa este token, se quita la entrada inmediatamente y se activan las devoluciones de llamada de expulsión:</span><span class="sxs-lookup"><span data-stu-id="b6938-226">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="b6938-227">Cuando se usa una devolución de llamada para volver a rellenar un elemento de caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-227">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="b6938-228">Varias solicitudes pueden encontrar el valor de clave en caché vacío porque la devolución de llamada no se ha completado.</span><span class="sxs-lookup"><span data-stu-id="b6938-228">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="b6938-229">Esto puede dar lugar a que varios subprocesos rellenen el elemento almacenado en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-229">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="b6938-230">Cuando se utiliza una entrada de caché para crear otra, el elemento secundario copia los tokens de expiración de la entrada primaria y la configuración de expiración basada en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="b6938-230">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="b6938-231">El elemento secundario no ha expirado porque se ha quitado o actualizado manualmente la entrada principal.</span><span class="sxs-lookup"><span data-stu-id="b6938-231">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="b6938-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> para establecer las devoluciones de llamada que se activarán después de que la entrada de caché se expulse de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="b6938-233">Para la mayoría de las aplicaciones, `IMemoryCache` está habilitada.</span><span class="sxs-lookup"><span data-stu-id="b6938-233">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="b6938-234">Por ejemplo, llamar a `AddMvc` , `AddControllersWithViews` , `AddRazorPages` , `AddMvcCore().AddRazorViewEngine` y muchos otros `Add{Service}` métodos de `ConfigureServices` , habilita `IMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="b6938-234">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="b6938-235">En el caso de las aplicaciones que no llamen a uno de los `Add{Service}` métodos anteriores, puede que sea necesario llamar a <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> en `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="b6938-235">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="b6938-236">Actualización de caché en segundo plano</span><span class="sxs-lookup"><span data-stu-id="b6938-236">Background cache update</span></span>

<span data-ttu-id="b6938-237">Use un [servicio en segundo plano](xref:fundamentals/host/hosted-services) como <xref:Microsoft.Extensions.Hosting.IHostedService> para actualizar la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-237">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="b6938-238">El servicio en segundo plano puede volver a calcular las entradas y asignarlas a la caché solo cuando estén listas.</span><span class="sxs-lookup"><span data-stu-id="b6938-238">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="b6938-239">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="b6938-239">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="b6938-240">Por [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)y [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="b6938-240">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="b6938-241">[Vea o descargue el código de ejemplo](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([cómo descargarlo](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="b6938-241">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="b6938-242">Conceptos básicos de almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="b6938-242">Caching basics</span></span>

<span data-ttu-id="b6938-243">El almacenamiento en caché puede mejorar significativamente el rendimiento y la escalabilidad de una aplicación reduciendo el trabajo necesario para generar contenido.</span><span class="sxs-lookup"><span data-stu-id="b6938-243">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="b6938-244">El almacenamiento en caché funciona mejor con los datos que cambian con poca frecuencia.</span><span class="sxs-lookup"><span data-stu-id="b6938-244">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="b6938-245">Caching realiza una copia de los datos que se pueden devolver mucho más rápido que desde el origen original.</span><span class="sxs-lookup"><span data-stu-id="b6938-245">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="b6938-246">Se debe escribir y probar el código para que **nunca** dependa de los datos almacenados en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-246">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="b6938-247">ASP.NET Core admite varias memorias caché diferentes.</span><span class="sxs-lookup"><span data-stu-id="b6938-247">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="b6938-248">La memoria caché más sencilla se basa en el [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), que representa una memoria caché almacenada en la memoria del servidor Web.</span><span class="sxs-lookup"><span data-stu-id="b6938-248">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="b6938-249">Las aplicaciones que se ejecutan en una granja de servidores (varios servidores) deben asegurarse de que las sesiones son permanentes al usar la memoria caché en memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-249">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="b6938-250">Las sesiones permanentes garantizan que todas las solicitudes posteriores de un cliente van al mismo servidor.</span><span class="sxs-lookup"><span data-stu-id="b6938-250">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="b6938-251">Por ejemplo, Azure Web Apps usa el [enrutamiento de solicitud de aplicaciones](https://www.iis.net/learn/extensions/planning-for-arr) (arr) para enrutar todas las solicitudes de un agente de usuario al mismo servidor.</span><span class="sxs-lookup"><span data-stu-id="b6938-251">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="b6938-252">Las sesiones no permanentes en una granja de servidores Web requieren una [caché distribuida](distributed.md) para evitar problemas de coherencia de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-252">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="b6938-253">En algunas aplicaciones, una caché distribuida puede admitir una mayor escalabilidad horizontal que una caché en memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-253">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="b6938-254">El uso de una caché distribuida descarga la memoria caché en un proceso externo.</span><span class="sxs-lookup"><span data-stu-id="b6938-254">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="b6938-255">La caché en memoria puede almacenar cualquier objeto.</span><span class="sxs-lookup"><span data-stu-id="b6938-255">The in-memory cache can store any object.</span></span> <span data-ttu-id="b6938-256">La interfaz de caché distribuida se limita a `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="b6938-256">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="b6938-257">Los elementos de caché del almacén de caché distribuida y en memoria como pares de clave y valor.</span><span class="sxs-lookup"><span data-stu-id="b6938-257">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="b6938-258">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="b6938-258">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="b6938-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Paquete NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) se puede usar con:</span><span class="sxs-lookup"><span data-stu-id="b6938-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="b6938-260">.NET Standard 2,0 o posterior.</span><span class="sxs-lookup"><span data-stu-id="b6938-260">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="b6938-261">Cualquier [implementación de .net](/dotnet/standard/net-standard#net-implementation-support) que tenga como destino .net Standard 2,0 o posterior.</span><span class="sxs-lookup"><span data-stu-id="b6938-261">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="b6938-262">Por ejemplo, ASP.NET Core 2,0 o posterior.</span><span class="sxs-lookup"><span data-stu-id="b6938-262">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="b6938-263">.NET Framework 4.5 o superior.</span><span class="sxs-lookup"><span data-stu-id="b6938-263">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="b6938-264">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (que se describe en este artículo) se recomienda en lugar de `System.Runtime.Caching` / `MemoryCache` que se integre mejor en ASP.net Core.</span><span class="sxs-lookup"><span data-stu-id="b6938-264">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="b6938-265">Por ejemplo, `IMemoryCache` funciona de forma nativa con la [inserción de dependencias](xref:fundamentals/dependency-injection)ASP.net Core.</span><span class="sxs-lookup"><span data-stu-id="b6938-265">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="b6938-266">Use `System.Runtime.Caching` / `MemoryCache` como puente de compatibilidad al trasladar código de ASP.net 4. x a ASP.net Core.</span><span class="sxs-lookup"><span data-stu-id="b6938-266">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="b6938-267">Instrucciones de caché</span><span class="sxs-lookup"><span data-stu-id="b6938-267">Cache guidelines</span></span>

* <span data-ttu-id="b6938-268">El código siempre debe tener una opción de reserva para capturar datos y **no** depender de que un valor almacenado en caché esté disponible.</span><span class="sxs-lookup"><span data-stu-id="b6938-268">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="b6938-269">La memoria caché utiliza un recurso y una memoria insuficientes.</span><span class="sxs-lookup"><span data-stu-id="b6938-269">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="b6938-270">Limitar el crecimiento de la caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-270">Limit cache growth:</span></span>
  * <span data-ttu-id="b6938-271">**No** utilice la entrada externa como claves de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-271">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="b6938-272">Use las expiraciones para limitar el crecimiento de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-272">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="b6938-273">[Use setSize, size y SizeLimit para limitar el tamaño de la memoria caché](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="b6938-273">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="b6938-274">El tiempo de ejecución de ASP.NET Core no limita el tamaño de la memoria caché en función de la presión de memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-274">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="b6938-275">Depende del desarrollador limitar el tamaño de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-275">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="b6938-276">Usar IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="b6938-276">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="b6938-277">El uso de una caché de memoria *compartida* de la [inserción de dependencias](xref:fundamentals/dependency-injection) y `SetSize` la llamada a, `Size` o `SizeLimit` para limitar el tamaño de la memoria caché puede provocar un error en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="b6938-277">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="b6938-278">Cuando se establece un límite de tamaño en una memoria caché, todas las entradas deben especificar un tamaño al agregarse.</span><span class="sxs-lookup"><span data-stu-id="b6938-278">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="b6938-279">Esto puede dar lugar a problemas, ya que es posible que los desarrolladores no tengan control total sobre lo que utiliza la memoria caché compartida.</span><span class="sxs-lookup"><span data-stu-id="b6938-279">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="b6938-280">Por ejemplo, Entity Framework Core usa la memoria caché compartida y no especifica un tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-280">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="b6938-281">Si una aplicación establece un límite de tamaño de caché y usa EF Core, la aplicación produce una excepción `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="b6938-281">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="b6938-282">Al usar `SetSize` , `Size` o `SizeLimit` para limitar la memoria caché, cree un singleton de caché para el almacenamiento en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-282">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="b6938-283">Para obtener más información y un ejemplo, vea [uso de setSize, size y SizeLimit para limitar el tamaño de la memoria caché](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="b6938-283">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="b6938-284">El almacenamiento en caché en memoria es un *servicio* al que se hace referencia desde la aplicación mediante la [inserción de dependencias](../../fundamentals/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="b6938-284">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="b6938-285">Llamar a `AddMemoryCache` en `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="b6938-285">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="b6938-286">Solicite la `IMemoryCache` instancia en el constructor:</span><span class="sxs-lookup"><span data-stu-id="b6938-286">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="b6938-287">`IMemoryCache`requiere el paquete NuGet [Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), que está disponible en el [metapaquete Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app).</span><span class="sxs-lookup"><span data-stu-id="b6938-287">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="b6938-288">En el código siguiente se usa [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) para comprobar si una hora está en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-288">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="b6938-289">Si una hora no está almacenada en caché, se crea una nueva entrada y se agrega a la memoria caché con [set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="b6938-289">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="b6938-290">Se muestran la hora actual y la hora almacenada en caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-290">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="b6938-291">El valor almacenado en caché `DateTime` permanece en la memoria caché mientras haya solicitudes dentro del período de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="b6938-291">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="b6938-292">En la imagen siguiente se muestra la hora actual y una hora anterior recuperada de la caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-292">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Vista de índice con dos horas diferentes mostradas](memory/_static/time.png)

<span data-ttu-id="b6938-294">En el código siguiente se usa [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) y [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) para almacenar datos en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-294">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="b6938-295">El siguiente código llama a [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) para capturar la hora almacenada en caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-295">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="b6938-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> y [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) son métodos de extensión que forman parte de la clase [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) que extiende la capacidad de <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="b6938-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="b6938-297">Vea métodos [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) y [métodos CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) para obtener una descripción de otros métodos de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-297">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="b6938-298">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="b6938-298">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="b6938-299">El ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="b6938-299">The following sample:</span></span>

* <span data-ttu-id="b6938-300">Establece una hora de expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-300">Sets a sliding expiration time.</span></span> <span data-ttu-id="b6938-301">Las solicitudes que tengan acceso a este elemento almacenado en caché restablecerán el reloj de expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-301">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="b6938-302">Establece la prioridad de la memoria caché en `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="b6938-302">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="b6938-303">Establece un [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) que se llamará después de que la entrada se expulse de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-303">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="b6938-304">La devolución de llamada se ejecuta en un subproceso diferente del código que quita el elemento de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-304">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="b6938-305">Use setSize, size y SizeLimit para limitar el tamaño de la memoria caché</span><span class="sxs-lookup"><span data-stu-id="b6938-305">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="b6938-306">`MemoryCache`Opcionalmente, una instancia puede especificar y exigir un límite de tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-306">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="b6938-307">El límite de tamaño de caché no tiene una unidad de medida definida porque la memoria caché no tiene ningún mecanismo para medir el tamaño de las entradas.</span><span class="sxs-lookup"><span data-stu-id="b6938-307">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="b6938-308">Si se establece el límite de tamaño de la caché, todas las entradas deben especificar el tamaño.</span><span class="sxs-lookup"><span data-stu-id="b6938-308">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="b6938-309">El tiempo de ejecución de ASP.NET Core no limita el tamaño de la memoria caché en función de la presión de memoria.</span><span class="sxs-lookup"><span data-stu-id="b6938-309">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="b6938-310">Depende del desarrollador limitar el tamaño de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-310">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="b6938-311">El tamaño especificado se encuentra en las unidades que el desarrollador elige.</span><span class="sxs-lookup"><span data-stu-id="b6938-311">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="b6938-312">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="b6938-312">For example:</span></span>

* <span data-ttu-id="b6938-313">Si la aplicación web estaba principalmente almacenando en caché cadenas, cada tamaño de entrada de caché podría ser la longitud de la cadena.</span><span class="sxs-lookup"><span data-stu-id="b6938-313">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="b6938-314">La aplicación puede especificar el tamaño de todas las entradas como 1 y el límite de tamaño es el recuento de entradas.</span><span class="sxs-lookup"><span data-stu-id="b6938-314">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="b6938-315">Si <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> no se establece, la caché crece sin enlazar.</span><span class="sxs-lookup"><span data-stu-id="b6938-315">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="b6938-316">El tiempo de ejecución de ASP.NET Core no recorta la memoria caché cuando la memoria del sistema es baja.</span><span class="sxs-lookup"><span data-stu-id="b6938-316">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="b6938-317">La arquitectura de las aplicaciones es:</span><span class="sxs-lookup"><span data-stu-id="b6938-317">Apps much be architected to:</span></span>

* <span data-ttu-id="b6938-318">Limitar el crecimiento de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-318">Limit cache growth.</span></span>
* <span data-ttu-id="b6938-319">Llame a <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> o <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> cuando la memoria disponible esté limitada:</span><span class="sxs-lookup"><span data-stu-id="b6938-319">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="b6938-320">En el código siguiente se crea un tamaño fijo no <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> disponible accesible por la [inserción de dependencias](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="b6938-320">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="b6938-321">`SizeLimit`no tiene unidades.</span><span class="sxs-lookup"><span data-stu-id="b6938-321">`SizeLimit` does not have units.</span></span> <span data-ttu-id="b6938-322">Las entradas almacenadas en caché deben especificar el tamaño en las unidades que consideren más adecuadas si se ha establecido el límite de tamaño de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-322">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="b6938-323">Todos los usuarios de una instancia de caché deben usar el mismo sistema de unidad.</span><span class="sxs-lookup"><span data-stu-id="b6938-323">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="b6938-324">Una entrada no se almacenará en caché si la suma de los tamaños de las entradas almacenadas en caché supera el valor especificado por `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="b6938-324">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="b6938-325">Si no se establece ningún límite de tamaño de caché, se omitirá el tamaño de la memoria caché establecido en la entrada.</span><span class="sxs-lookup"><span data-stu-id="b6938-325">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="b6938-326">El código siguiente se registra `MyMemoryCache` con el contenedor de [inserción de dependencias](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="b6938-326">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="b6938-327">`MyMemoryCache`se crea como una caché de memoria independiente para los componentes que tienen en cuenta esta caché de tamaño limitado y saben cómo establecer el tamaño de la entrada de caché de forma adecuada.</span><span class="sxs-lookup"><span data-stu-id="b6938-327">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="b6938-328">El código siguiente usa `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="b6938-328">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="b6938-329">El tamaño de la entrada de caché se puede establecer por [tamaño](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) o por el método de extensión [setSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) :</span><span class="sxs-lookup"><span data-stu-id="b6938-329">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="b6938-330">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="b6938-330">MemoryCache.Compact</span></span>

<span data-ttu-id="b6938-331">`MemoryCache.Compact`intenta quitar el porcentaje especificado de la memoria caché en el siguiente orden:</span><span class="sxs-lookup"><span data-stu-id="b6938-331">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="b6938-332">Todos los elementos expirados.</span><span class="sxs-lookup"><span data-stu-id="b6938-332">All expired items.</span></span>
* <span data-ttu-id="b6938-333">Elementos por prioridad.</span><span class="sxs-lookup"><span data-stu-id="b6938-333">Items by priority.</span></span> <span data-ttu-id="b6938-334">En primer lugar, se quitan los elementos de prioridad más baja.</span><span class="sxs-lookup"><span data-stu-id="b6938-334">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="b6938-335">Objetos usados menos recientemente.</span><span class="sxs-lookup"><span data-stu-id="b6938-335">Least recently used objects.</span></span>
* <span data-ttu-id="b6938-336">Elementos con la expiración absoluta más temprana.</span><span class="sxs-lookup"><span data-stu-id="b6938-336">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="b6938-337">Elementos con la primera expiración variable.</span><span class="sxs-lookup"><span data-stu-id="b6938-337">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="b6938-338">Los elementos anclados con prioridad <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nunca se quitan.</span><span class="sxs-lookup"><span data-stu-id="b6938-338">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="b6938-339">Consulte [código fuente compacto en github](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="b6938-339">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="b6938-340">Dependencias de caché</span><span class="sxs-lookup"><span data-stu-id="b6938-340">Cache dependencies</span></span>

<span data-ttu-id="b6938-341">En el ejemplo siguiente se muestra cómo expirar una entrada de caché si una entrada dependiente expira.</span><span class="sxs-lookup"><span data-stu-id="b6938-341">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="b6938-342"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Se agrega al elemento almacenado en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-342">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="b6938-343">Cuando `Cancel` se llama a en `CancellationTokenSource` , se expulsan ambas entradas de caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-343">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="b6938-344">El uso de `CancellationTokenSource` permite desalojar varias entradas de caché como un grupo.</span><span class="sxs-lookup"><span data-stu-id="b6938-344">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="b6938-345">Con el `using` patrón en el código anterior, las entradas de caché que se crean dentro del `using` bloque heredarán los desencadenadores y la configuración de expiración.</span><span class="sxs-lookup"><span data-stu-id="b6938-345">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="b6938-346">Notas adicionales</span><span class="sxs-lookup"><span data-stu-id="b6938-346">Additional notes</span></span>

* <span data-ttu-id="b6938-347">Cuando se usa una devolución de llamada para volver a rellenar un elemento de caché:</span><span class="sxs-lookup"><span data-stu-id="b6938-347">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="b6938-348">Varias solicitudes pueden encontrar el valor de clave en caché vacío porque la devolución de llamada no se ha completado.</span><span class="sxs-lookup"><span data-stu-id="b6938-348">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="b6938-349">Esto puede dar lugar a que varios subprocesos rellenen el elemento almacenado en caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-349">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="b6938-350">Cuando se utiliza una entrada de caché para crear otra, el elemento secundario copia los tokens de expiración de la entrada primaria y la configuración de expiración basada en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="b6938-350">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="b6938-351">El elemento secundario no ha expirado porque se ha quitado o actualizado manualmente la entrada principal.</span><span class="sxs-lookup"><span data-stu-id="b6938-351">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="b6938-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) para establecer las devoluciones de llamada que se activarán después de que la entrada de caché se expulse de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="b6938-353">Actualización de caché en segundo plano</span><span class="sxs-lookup"><span data-stu-id="b6938-353">Background cache update</span></span>

<span data-ttu-id="b6938-354">Use un [servicio en segundo plano](xref:fundamentals/host/hosted-services) como <xref:Microsoft.Extensions.Hosting.IHostedService> para actualizar la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="b6938-354">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="b6938-355">El servicio en segundo plano puede volver a calcular las entradas y asignarlas a la caché solo cuando estén listas.</span><span class="sxs-lookup"><span data-stu-id="b6938-355">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="b6938-356">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="b6938-356">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
